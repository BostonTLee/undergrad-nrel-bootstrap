---
title: "Time Series Bootstrapping For Solar Current"
author: "Evan Kessler, Adam Kiehl, and Boston Lee"
date: "2021/12/16"
output: pdf_document
---

```{r reprod}
set.seed(400)
```

```{r libs, include=FALSE, message=FALSE}
library(tidyverse)
library(boot)
```

```{r data, message=FALSE, warning=FALSE}
df <- read_csv("../data/final/irradiance_full_final.csv") %>%
  select(-'...1')
```

```{r plot-pres-func}
make_plot_for_pres <- function(plot) {
  ret_plot <- plot +
    theme(text = element_text(size = 21))
  return(ret_plot)
}
```

# EDA

```{r timeseries, warning=FALSE}

#' Plot a timeseries of a single variable
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @param n_days The number of days (starting from the
#'    beginning of the data) to plot
#' @return A ggplot object of a timeseries of `variable` for `n_days` days
time_series_of_var <- function(df, variable, var_name, n_days) {
  ret_plot <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    head(24 * n_days) %>%
    ggplot() +
    geom_line(aes_string(x = "date", y = variable)) +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

time_series_ghi <- time_series_of_var(df, "GHI", "GHI", 6)
time_series_current <- time_series_of_var(df, "current_out", "Output current", 6)
ggsave("./images/time_series_ghi.png", make_plot_for_pres(time_series_ghi))
ggsave("./images/time_series_current.png", make_plot_for_pres(time_series_current))
```

```{r hour-plot}

#' Plot the values of `variable` at each hour of the day
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @return A ggplot object of a boxplot of `variable` segmented by hour
hour_plot_of_var <- function(df, variable, var_name) {
  df$Hour <- as.factor(df$Hour)
  ret_plot <- df %>%
    ggplot() +
    geom_boxplot(aes_string(x = "Hour", y = variable)) +
    xlab("Hour (0-23)") +
    ylab(paste("Distribution of", var_name)) +
    scale_x_discrete(breaks = seq(0, 23, 2)) +
    theme_bw()
  return(ret_plot)
}

hour_plot_ghi <- hour_plot_of_var(df, "GHI", "GHI")
hour_plot_current <- hour_plot_of_var(df, "current_out", "output current")
ggsave("./images/hour_plot_ghi.png", make_plot_for_pres(hour_plot_ghi))
ggsave("./images/hour_plot_current.png", make_plot_for_pres(hour_plot_current))
```


# Data filtering

```{r filter}
HOUR_WINDOW <- 11:16
df_high_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out, y = ..density..), binwidth = .0025) +
  theme_bw() +
  labs(title='Distribution of Current Outputs', subtitle='Restricted to high irradiance hours of the day', 
       x = 'Current Output', y = 'Density')
print(filtered_current_hist)
```

# Bootstrapping

```{r functions}

#' Given a dataframe, return a matrix of bootstrap blocks
#'
#' @param df A dataframe of irradiance values
#' @return A matrix whose rows are bootstrap blocks
make_blocks_from_df <- function(df) {
  df <- df %>%
    mutate(date = lubridate::make_date(Year, Month, Day))
  # The number of blocks is the number of days
  number_of_blocks <- length(unique(df$date))
  # The length of a block is the number of
  # observations in each individual day.
  # In this case, we can simply look at the first one,
  # because all of the days have the same number of observations
  length_of_block <- nrow(df[df$date == unique(df$date)[1], ])
  blocks <- matrix(NA, nrow = number_of_blocks, ncol = length_of_block)
  start <- 1
  stop <- length_of_block
  for (i in 1:number_of_blocks) {
    # blocks[i, ] <- df$current_out[(i - 1) * length_of_block + 1 : (i * length_of_block)]
    blocks[i, ] <- df$current_out[start:stop]
    start <- start + length_of_block
    stop <- stop + length_of_block
  }
  return(blocks)
}
# We have to use the modified DataFrame here,
# or else the assumptions about block size don't hold
test <- make_blocks_from_df(df_high_irradiance)

block_bootstrap_estimates_from_df <- function(df, B = 10000) {
  block_bootstrap_estimates <- rep(NA, B)
  blocks <- make_blocks_from_df(df)
  number_of_blocks <- nrow(blocks)
  for (i in 1:B) {
    # sample blocks
    idx <- sample(1:number_of_blocks, number_of_blocks, replace = TRUE)
    # Concatenate blocks at the given indices
    # This gives a "pseudo-dataset" containing resampled blocks
    block_bootstrap_estimates[i] <- mean(as.vector(t(blocks[idx, ])))
  }
  return(block_bootstrap_estimates)
}

meanv <- function(data, idx) {
  return(mean(data[idx]))
}

sdv <- function(data, idx) {
  return(sd(data[idx]))
}

medianv <- function(data, idx) {
  return(median(data[idx]))
}

iid_bootstrap_estimates_from_df <- function(df, B = 10000) {
  boot_current <- boot(df$current_out, meanv, B)
  return(boot_current$t)
}

boot_block <- block_bootstrap_estimates_from_df(df_high_irradiance)
boot_block_df <- data.frame(boot = boot_block, type = rep("Block", length(boot_block)))
boot_iid <- iid_bootstrap_estimates_from_df(df_high_irradiance)
boot_iid_df <- data.frame(boot = boot_iid, type = rep("iid", length(boot_iid)))

vis_df <- rbind(boot_block_df, boot_iid_df)

# percentile bootstrap CI used
alpha <- .05
block_ci <- quantile(boot_block_df$boot, c(alpha / 2, 1 - alpha / 2))
iid_ci <- quantile(boot_iid_df$boot, c(alpha / 2, 1 - alpha / 2))

mean_boot_plot <- ggplot(vis_df) +
  geom_histogram(aes(x = boot, y = ..density.., fill = type), position = "identity", alpha = .5, color = "black", 
                 binwidth = .0001) +
  # geom_segment(aes(x = block_ci[1], xend = block_ci[2], y = 1250, yend = 1250), color = 'tomato', alpha = .01) +
  geom_vline(aes(xintercept = block_ci[1]), linetype = 'dashed', color = 'tomato', alpha = .5) +
  geom_vline(aes(xintercept = block_ci[2]), linetype = 'dashed', color = 'tomato', alpha = .5) +
  # geom_segment(aes(x = iid_ci[1], xend = iid_ci[2], y = 1300, yend = 1300), color = 'turquoise3', alpha = .01) +
  geom_vline(aes(xintercept = iid_ci[1]), linetype = 'dashed', color = 'turquoise3', alpha = .5) +
  geom_vline(aes(xintercept = iid_ci[2]), linetype = 'dashed', color = 'turquoise3', alpha = .5) +
  labs(fill = "Bootstrap Type", title='Bootstrapped Current Output', subtitle = 'Percentile confidence intervals given', 
       x = 'Bootstrap Sample Means', y = 'Density') +
  theme_bw()
ggsave("./images/mean_boot_plot.png", make_plot_for_pres(mean_boot_plot), width = 16, height = 12)
```

```{r}
# rough MC coverage estimate assuming dependent bootstrap distribution as a null
B <- 10000
n <- nrow(boot_block_df)

lower <- as.numeric(iid_ci[1])
upper <- as.numeric(iid_ci[2])

mu <- mean(boot_block_df$boot)
sigma <- sd(boot_block_df$boot)

sample <- rnorm(B, mu, sigma)

sum(sample >= lower & sample <= upper) / n
```

```{r sampling}
time_series_irradiance <- function(df, variable, var_name, hour_range) {
  newdf <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    # each day in this dataset is subset from 11:16, meaning there is 6 hours per day
    head(hour_range * 6)
  
  blocks <- c(newdf$date[seq(1,length(newdf$date), hour_range)])
 
  re_plot <- ggplot(newdf) +
    geom_line(aes_string(x = "date", y = variable)) +
    geom_vline(xintercept = blocks, colour = "red") +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

sixhr_plot_current <- time_series_irradiance(df_high_irradiance, "current_out", "Current Output", 6)
ggsave("./images/sixhr_plot_current.png", make_plot_for_pres(sixhr_plot_current))

HOUR_WINDOW <- 8:19
df_more_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out)) +
  theme_bw()
print(filtered_current_hist)

twelvehr_plot_current <- time_series_irradiance(df_more_irradiance, "current_out", "Current Output", 12)
ggsave("./images/twelvehr_plot_current.png", make_plot_for_pres(twelvehr_plot_current))

day_plot_current <- time_series_irradiance(df, "current_out", "Current Output", 24)
ggsave("./images/day_plot_current.png", make_plot_for_pres(day_plot_current))


# B1 <- df[df$Hour == c(7:10),]$current_output # Hours before peak
# B2 <- df[df$Hour == c(11:14),]$current_output # Peak hours
# B3 <- df[df$Hour == c(15:18),]$current_output # Hours after peak

# nbb(hours, 4) # in order to make b blocks I would need to solve for b = [n/l] (floor) where n is the length of our data and l is 4, so make nbb call l instead of ib

# nbb(hours, 12)

# Could also block instead by hours but by total current output. Peak hours
# would be a frame around the highest output and then hours before and after
# would coincide with that. This would cause the hours to potentially be
# different based on the season/month as months that get dark earlier could see
# peak hours earlier in the day.

# dpeak <- c(B1,B2,B3)
```

- We chose our initial paper because of its use of Monte Carlo. After working with it for a little it was brought to our attention that Monte Carlo was used in conjunction with a backward/forward sweep method in order to calculate the pdf. After some confusion it was decided to switch to another paper dealing with the same data/motivation but without said methods (including Monte Carlo).
- Luckily, the week after we switched papers we begun learning about bootstrapping, a way to sample from our data while taking into consideration our time change. 

INSERT GRAPHS FROM IID BOOTSTRAPPING AND BLOCK HERE
ALSO INSERT FIG 1 FROM PAPER

- The paper focused most of their sampling on night-day clustering, showing the difference between night and day through current. Night yielded thousands of 0 current values, leading to skewed data when sampling. Instead we took too approaches to bootstrap the current vs. hour data.
- One using non-overlapping blocks sampling from the 8 hours surrounding the peak irradiance. The other being IID, yielding dependence in our data. 
