---
title: "Time Series Bootstrapping For Solar Current"
author: "Evan Kessler, Adam Kiehl, and Boston Lee"
date: "2021/12/16"
output: pdf_document
---

```{r reprod}
set.seed(400)
```

```{r libs, include=FALSE, message=FALSE}
library(tidyverse)
library(boot)
```

```{r data, message=FALSE, warning=FALSE}
df <- read_csv("../data/final/irradiance_full_final.csv") %>%
  select(-'...1')
```

```{r plot-pres-func}
make_plot_for_pres <- function(plot) {
  ret_plot <- plot +
    theme(text = element_text(size = 21))
  return(ret_plot)
}
```

# EDA

```{r timeseries, warning=FALSE}

#' Plot a timeseries of a single variable
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @param n_days The number of days (starting from the
#'    beginning of the data) to plot
#' @return A ggplot object of a timeseries of `variable` for `n_days` days
time_series_of_var <- function(df, variable, var_name, n_days) {
  ret_plot <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    head(24 * n_days) %>%
    ggplot() +
    geom_line(aes_string(x = "date", y = variable)) +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

time_series_ghi <- time_series_of_var(df, "GHI", "GHI", 6)
time_series_current <- time_series_of_var(df, "current_out", "Output current", 6)
ggsave("./images/time_series_ghi.png", make_plot_for_pres(time_series_ghi))
ggsave("./images/time_series_current.png", make_plot_for_pres(time_series_current))
```

```{r hour-plot}

#' Plot the values of `variable` at each hour of the day
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @return A ggplot object of a boxplot of `variable` segmented by hour
hour_plot_of_var <- function(df, variable, var_name) {
  df$Hour <- as.factor(df$Hour)
  ret_plot <- df %>%
    ggplot() +
    geom_boxplot(aes_string(x = "Hour", y = variable)) +
    xlab("Hour (0-23)") +
    ylab(paste("Distribution of", var_name)) +
    scale_x_discrete(breaks = seq(0, 23, 2)) +
    theme_bw()
  return(ret_plot)
}

hour_plot_ghi <- hour_plot_of_var(df, "GHI", "GHI")
hour_plot_current <- hour_plot_of_var(df, "current_out", "output current")
ggsave("./images/hour_plot_ghi.png", make_plot_for_pres(hour_plot_ghi))
ggsave("./images/hour_plot_current.png", make_plot_for_pres(hour_plot_current))
```

# Preprocessing

To translate raw irradiance data into meaningful current data, several steps had to be taken to simulate the electrical workings of a real PV module. First, adjustments had to be made to account for the fact that an imperfect amount of irradiance actually reaches a PV module for capture. Then, effective irradiance must be translated into output current and maximized with an attached power processor. The process and accompanying assumptions are given below. 

## Effective Irradiance

The effective irradiance that reaches a PV module is different from the total irradiance emitted by the sun due to a variety of small considerations that must be made. Among these are the tilt and rotation of the Earth, the latitude and longitude of the PV module, and the inclination of the panel towards the horizon. Most simply, $I_{eff} \propto I_{sun} cos \theta(t, N)$ where $\theta \in [-\frac{\pi}{2},\frac{\pi}{2}]$ is the angle between the sunlight and the surface of the solar cell. 
$$
\begin{aligned}
cos \theta(t, N) = & sin \gamma(N) sin La cos \beta - \\
& sin \gamma(N) cos La sin \beta cos \alpha + \\
& cos \gamma(N) cos La cos \beta cos w(t,N) + \\
& cos \gamma(N) sin La sin \beta cos \alpha cos w(t,N) + \\
& cos \gamma(N) sin \beta sin \alpha sin w(t,N) \\
\end{aligned}
$$
Here, $\gamma (N) = sin^{-1}[sin(.409)sin(D(N))]$ is known as the declination angle and is calculated from the angle of the Earth's axis and a metric $D(N) = 360(N - 81)/360$ where $N \in [1, 365]$ is the day of the year. $La \in [0, \frac{\pi}{2}]$ is the latitude of the PV module in radians. $\alpha = .524$ corresponds to whether the panel faces East or West and $\beta = .785$ describes the angle between the panel and the horizon; these values were supplied as assumptions. Finally, the hour angle $w(t, N)$ accounts for the angle of sunlight given the rotation of the Earth. 
$$
\begin{aligned}
w(t,N) &= 15 (AST(t,N) - 12) \\
AST(t,N) &= t + \Delta t + ET(N) \\
&= t + \frac{Lo - 15 UTC_{off}}{15} + ET(N) \\
ET(N) &= [9.87sin(2D(N)) - 7.53cos(D(N)) - 1.5sin(D(N))] / 60
\end{aligned}
$$
Here, $AST(t,N) \in [0,24]$ is the apparent solar time relative to the sun and is calculated as an adjustment to the current time $t$ based on longitude $Lo$, an offset from the coordinated universal time $UTC_{off}$, and the equation of time $ET(N)$. The above calculations produce results in degrees but values were switched to radians before trigonometric functions were applied. Ultimately, $I_{eff} \propto I_{sun} cos \theta(t, N)$ resulted from our astronomical adjustments and was used for PV module calculations. 

## PV Module

Within the PV module, effective irradiance is translated into output current but the entire process is regulated by an attached power processor that ensure that the maximum power is extracted. It does this by testing a range of open circuit voltages $v_{oc}$ between zero and an assumed maximum $v_{oc} = 1.8$ on the PV module's I-V curve which describes how current and voltage vary together for each solar cell in the module. Here, the I-V curve is given by 
$$
i_{out} = i_{l} - i_{o}[e^{\frac{qv}{n \kappa T}} - 1]
$$ 
with constants $q = 1.6*10^{-19}$ and $\kappa = 1.38 * 10^{-23}$. The light-generated current $i_{l}(t,N) = .0005 I_{eff}(t,N)$ which adjusts $I_{eff}$ for the assumed short circuit current $i_{sc} = 5$ and a radiation rate factor. With a leakage factor $i_{o}$ and the ambient temperature $T$ in degrees Kelvin, $i_{out}$ can be calculated for various voltage values. The combined power of the module is then calculated by 
$$
P = n_{p} n_{s} max\{i_{out} v\}
$$ 
where $n_{p} = 6$ is the assumed number of parallel-wired solar cells in the module and $n_{s} = 6$ is the assumed number of series-wired solar cells in the module. A final conversion efficiency factor $\eta = .211$ is applied and $P'_{max} = \eta P_{max}$ is returned. 

# Data filtering

```{r filter}
HOUR_WINDOW <- 11:16
df_high_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out, y = ..density..), binwidth = .0025) +
  theme_bw() +
  labs(title='Distribution of Current Outputs', subtitle='Restricted to high irradiance hours of the day', 
       x = 'Current Output', y = 'Density')
print(filtered_current_hist)
```

# Bootstrapping

```{r functions}

#' Given a dataframe, return a matrix of bootstrap blocks
#'
#' @param df A dataframe of irradiance values
#' @return A matrix whose rows are bootstrap blocks
make_blocks_from_df <- function(df) {
  df <- df %>%
    mutate(date = lubridate::make_date(Year, Month, Day))
  # The number of blocks is the number of days
  number_of_blocks <- length(unique(df$date))
  # The length of a block is the number of
  # observations in each individual day.
  # In this case, we can simply look at the first one,
  # because all of the days have the same number of observations
  length_of_block <- nrow(df[df$date == unique(df$date)[1], ])
  blocks <- matrix(NA, nrow = number_of_blocks, ncol = length_of_block)
  start <- 1
  stop <- length_of_block
  for (i in 1:number_of_blocks) {
    # blocks[i, ] <- df$current_out[(i - 1) * length_of_block + 1 : (i * length_of_block)]
    blocks[i, ] <- df$current_out[start:stop]
    start <- start + length_of_block
    stop <- stop + length_of_block
  }
  return(blocks)
}
# We have to use the modified DataFrame here,
# or else the assumptions about block size don't hold
test <- make_blocks_from_df(df_high_irradiance)

block_bootstrap_estimates_from_df <- function(df, B = 10000) {
  block_bootstrap_estimates <- rep(NA, B)
  blocks <- make_blocks_from_df(df)
  number_of_blocks <- nrow(blocks)
  for (i in 1:B) {
    # sample blocks
    idx <- sample(1:number_of_blocks, number_of_blocks, replace = TRUE)
    # Concatenate blocks at the given indices
    # This gives a "pseudo-dataset" containing resampled blocks
    block_bootstrap_estimates[i] <- mean(as.vector(t(blocks[idx, ])))
  }
  return(block_bootstrap_estimates)
}

meanv <- function(data, idx) {
  return(mean(data[idx]))
}

sdv <- function(data, idx) {
  return(sd(data[idx]))
}

medianv <- function(data, idx) {
  return(median(data[idx]))
}

iid_bootstrap_estimates_from_df <- function(df, B = 10000) {
  boot_current <- boot(df$current_out, meanv, B)
  return(boot_current$t)
}

boot_block <- block_bootstrap_estimates_from_df(df_high_irradiance)
boot_block_df <- data.frame(boot = boot_block, type = rep("Block", length(boot_block)))
boot_iid <- iid_bootstrap_estimates_from_df(df_high_irradiance)
boot_iid_df <- data.frame(boot = boot_iid, type = rep("iid", length(boot_iid)))

vis_df <- rbind(boot_block_df, boot_iid_df)

# percentile bootstrap CI used
alpha <- .05
block_ci <- quantile(boot_block_df$boot, c(alpha / 2, 1 - alpha / 2))
iid_ci <- quantile(boot_iid_df$boot, c(alpha / 2, 1 - alpha / 2))

mean_boot_plot <- ggplot(vis_df) +
  geom_histogram(aes(x = boot, y = ..density.., fill = type), position = "identity", alpha = .5, color = "black", 
                 binwidth = .0001) +
  # geom_segment(aes(x = block_ci[1], xend = block_ci[2], y = 1250, yend = 1250), color = 'tomato', alpha = .01) +
  geom_vline(aes(xintercept = block_ci[1]), linetype = 'dashed', color = 'tomato', alpha = .5) +
  geom_vline(aes(xintercept = block_ci[2]), linetype = 'dashed', color = 'tomato', alpha = .5) +
  # geom_segment(aes(x = iid_ci[1], xend = iid_ci[2], y = 1300, yend = 1300), color = 'turquoise3', alpha = .01) +
  geom_vline(aes(xintercept = iid_ci[1]), linetype = 'dashed', color = 'turquoise3', alpha = .5) +
  geom_vline(aes(xintercept = iid_ci[2]), linetype = 'dashed', color = 'turquoise3', alpha = .5) +
  labs(fill = "Bootstrap Type", title='Bootstrapped Current Output', subtitle = 'Percentile confidence intervals given', 
       x = 'Bootstrap Sample Means', y = 'Density') +
  theme_bw()
ggsave("./images/mean_boot_plot.png", make_plot_for_pres(mean_boot_plot), width = 16, height = 12)
```

```{r}
# rough MC coverage estimate assuming dependent bootstrap distribution as a null
B <- 10000
n <- nrow(boot_block_df)

lower <- as.numeric(iid_ci[1])
upper <- as.numeric(iid_ci[2])

mu <- mean(boot_block_df$boot)
sigma <- sd(boot_block_df$boot)

sample <- rnorm(B, mu, sigma)

sum(sample >= lower & sample <= upper) / n
```

```{r sampling}
time_series_irradiance <- function(df, variable, var_name, hour_range) {
  newdf <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    # each day in this dataset is subset from 11:16, meaning there is 6 hours per day
    head(hour_range * 6)
  
  blocks <- c(newdf$date[seq(1,length(newdf$date), hour_range)])
 
  ret_plot <- ggplot(newdf) +
    geom_line(aes_string(x = "date", y = variable)) +
    geom_vline(xintercept = blocks, colour = "red") +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

sixhr_plot_current <- time_series_irradiance(df_high_irradiance, "current_out", "Current Output", 6)
ggsave("./images/sixhr_plot_current.png", make_plot_for_pres(sixhr_plot_current))

HOUR_WINDOW <- 8:19
df_more_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out)) +
  theme_bw()
print(filtered_current_hist)

twelvehr_plot_current <- time_series_irradiance(df_more_irradiance, "current_out", "Current Output", 12)
ggsave("./images/twelvehr_plot_current.png", make_plot_for_pres(twelvehr_plot_current))

day_plot_current <- time_series_irradiance(df, "current_out", "Current Output", 24)
ggsave("./images/day_plot_current.png", make_plot_for_pres(day_plot_current))


# B1 <- df[df$Hour == c(7:10),]$current_output # Hours before peak
# B2 <- df[df$Hour == c(11:14),]$current_output # Peak hours
# B3 <- df[df$Hour == c(15:18),]$current_output # Hours after peak

# nbb(hours, 4) # in order to make b blocks I would need to solve for b = [n/l] (floor) where n is the length of our data and l is 4, so make nbb call l instead of ib

# nbb(hours, 12)

# Could also block instead by hours but by total current output. Peak hours
# would be a frame around the highest output and then hours before and after
# would coincide with that. This would cause the hours to potentially be
# different based on the season/month as months that get dark earlier could see
# peak hours earlier in the day.

# dpeak <- c(B1,B2,B3)
```

- We chose our initial paper because of its use of Monte Carlo. After working with it for a little it was brought to our attention that Monte Carlo was used in conjunction with a backward/forward sweep method in order to calculate the pdf. After some confusion it was decided to switch to another paper dealing with the same data/motivation but without said methods (including Monte Carlo).
- Luckily, the week after we switched papers we begun learning about bootstrapping, a way to sample from our data while taking into consideration our time change. 

INSERT GRAPHS FROM IID BOOTSTRAPPING AND BLOCK HERE
ALSO INSERT FIG 1 FROM PAPER

- The paper focused most of their sampling on night-day clustering, showing the difference between night and day through current. Night yielded thousands of 0 current values, leading to skewed data when sampling. Instead we took too approaches to bootstrap the current vs. hour data.
- One using non-overlapping blocks sampling from the 8 hours surrounding the peak irradiance. The other being IID, yielding dependence in our data. 
