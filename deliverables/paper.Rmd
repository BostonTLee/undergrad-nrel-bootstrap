---
title: "Time Series Bootstrapping For Solar Current"
author: "Evan Kessler, Adam Kiehl, and Boston Lee"
date: "2021/12/16"
output: pdf_document
bibliography: references.bib
---

```{r reprod, include=FALSE}
# Reproducibility
set.seed(400)
```

```{r libs, include=FALSE, message=FALSE}
# Import packages
library(knitr)
library(tidyverse)
library(boot)
```

```{r data, include=FALSE, message=FALSE, warning=FALSE}
# Read in preprocessed data
df <- read_csv("../data/final/irradiance_full_final.csv")
```

```{r plot-pres-func, include=FALSE}
# Function to format plots for use in presentation
make_plot_for_pres <- function(plot) {
  ret_plot <- plot +
    theme(text = element_text(size = 21))
  return(ret_plot)
}
```

# Background

TODO

# Data

The data used was from the National Solar Radiation Database (NSRDB),
provided by the National Renewable Energy Laboratory
(NREL) (@nsrdb).
The data was acquired via the NSRDB API (@nsrdb_api).


The model paper for this project, @miozzo_2014
used data cited from the NSRDB.
However,
there were some discrepancies between our data
and the data used in @miozzo_2014.
Firstly, the year range in the paper was 1991--2010,
while the year range available when we acquired
the data from the NSRDB API was 1998--2010.
Secondly, the primary variable used in 
was extraterrestrial radiation,
"the amount of global horizontal radiation that a location on Earth would
receive if there was no atmosphere" (@nrel_glossary).
Our primary measure was global horizontal radiation (GHI),
which is the total solar radiation to reach
a horizontal plane on the Earth's surface (@nrel_glossary).
Because ETR and GHI are closely related,
we felt that the data was acceptable for a
replication of the process in @miozzo_2014,
with the caveat that the calculations may only be approximate.

## Data filtering

```{r filter, include=FALSE}
HOUR_WINDOW <- 11:16
df_high_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out, y = ..density..), binwidth = .0025) +
  theme_bw() +
  labs(
    title = "Distribution of Current Outputs", subtitle = "Restricted to high irradiance hours of the day",
    x = "Current Output", y = "Density"
  )
print(filtered_current_hist)
```

# EDA

```{r timeseries, include=FALSE, warning=FALSE}

#' Plot a timeseries of a single variable
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @param n_days The number of days (starting from the
#'    beginning of the data) to plot
#' @return A ggplot object of a timeseries of `variable` for `n_days` days
time_series_of_var <- function(df, variable, var_name, n_days) {
  ret_plot <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    head(24 * n_days) %>%
    ggplot() +
    geom_line(aes_string(x = "date", y = variable)) +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

time_series_ghi <- time_series_of_var(df, "GHI", "GHI", 6)
time_series_current <- time_series_of_var(df, "current_out", "Output current", 6)
ggsave("./images/time_series_ghi.png", make_plot_for_pres(time_series_ghi))
ggsave("./images/time_series_current.png", make_plot_for_pres(time_series_current))
```

```{r hour-plot, include=FALSE}

#' Plot the values of `variable` at each hour of the day
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @return A ggplot object of a boxplot of `variable` segmented by hour
hour_plot_of_var <- function(df, variable, var_name) {
  df$Hour <- as.factor(df$Hour)
  ret_plot <- df %>%
    ggplot() +
    geom_boxplot(aes_string(x = "Hour", y = variable)) +
    xlab("Hour (0-23)") +
    ylab(paste("Distribution of", var_name)) +
    scale_x_discrete(breaks = seq(0, 23, 2)) +
    theme_bw()
  return(ret_plot)
}

hour_plot_ghi <- hour_plot_of_var(df, "GHI", "GHI")
hour_plot_current <- hour_plot_of_var(df, "current_out", "output current")
ggsave("./images/hour_plot_ghi.png", make_plot_for_pres(hour_plot_ghi))
ggsave("./images/hour_plot_current.png", make_plot_for_pres(hour_plot_current))
```

# Preprocessing

To translate raw irradiance data into meaningful current data, several steps
had to be taken to simulate the electrical workings of a real PV module. First,
adjustments had to be made to account for the fact that an imperfect amount of
irradiance actually reaches a PV module for capture. Then, effective irradiance
must be translated into output current and maximized with an attached power
processor. The process and accompanying assumptions are given below. 

## Effective Irradiance

The effective irradiance that reaches a PV module is different from the total
irradiance emitted by the sun due to a variety of small considerations that
must be made. Among these are the tilt and rotation of the Earth, the latitude
and longitude of the PV module, and the inclination of the panel towards the
horizon. Most simply, $I_{eff} \propto I_{sun} cos \theta(t, N)$ where $\theta
\in [-\frac{\pi}{2},\frac{\pi}{2}]$ is the angle between the sunlight and the
surface of the solar cell [@miozzo_2014, p. 689]. 
$$
\begin{aligned}
cos \theta(t, N) = & sin \gamma(N) sin La cos \beta - \\
& sin \gamma(N) cos La sin \beta cos \alpha + \\
& cos \gamma(N) cos La cos \beta cos \omega(t,N) + \\
& cos \gamma(N) sin La sin \beta cos \alpha cos \omega(t,N) + \\
& cos \gamma(N) sin \beta sin \alpha sin \omega(t,N) \\
\end{aligned}
$$
Here, $\gamma (N) = sin^{-1}[sin(.409)sin(D(N))]$ is known as the declination angle and is calculated from the angle of the Earth's axis and a metric $D(N) = 360(N - 81)/360$ where $N \in [1, 365]$ is the day of the year [@miozzo_2014, p. 689]. $La \in [0, \frac{\pi}{2}]$ is the latitude of the PV module in radians [@miozzo_2014, p. 689]. $\alpha = .524$ corresponds to whether the panel faces East or West and $\beta = .785$ describes the angle between the panel and the horizon [@miozzo_2014, p. 689].
The constants $\alpha$ and $\beta$
were supplied as assumptions based on the location of the NSRDB
data [@miozzo_2014, p. 691].
Finally, the hour angle $\omega(t, N)$ accounts for the angle of sunlight given the rotation of the Earth [@miozzo_2014, p. 689]. 
$$
\begin{aligned}
w(t,N) &= 15 (AST(t,N) - 12) \\
AST(t,N) &= t + \Delta t + ET(N) \\
&= t + \frac{Lo - 15 UTC_{off}}{15} + ET(N) \\
ET(N) &= [9.87sin(2D(N)) - 7.53cos(D(N)) - 1.5sin(D(N))] / 60
\end{aligned}
$$
Here, $AST(t,N) \in [0,24]$ is the apparent solar time relative to the sun and is calculated as an adjustment to the current time $t$ based on longitude $Lo$, an offset from the coordinated universal time $UTC_{off}$, and the equation of time $ET(N)$ [@miozzo_2014, p. 689].
The above calculations produce results in degrees but values were switched to radians before trigonometric functions were applied.
Ultimately, $I_{eff} \propto I_{sun} cos \theta(t, N)$ resulted from our astronomical adjustments and was used for PV module
calculations [@miozzo_2014, p. 689]. 

## PV Module

Within the PV module, effective irradiance is translated into output current
but the entire process is regulated by an attached power processor that ensure
that the maximum power is extracted. It does this by testing a range of open
circuit voltages $v_{oc}$ between zero and an assumed maximum $v_{oc} = 1.8$ on
the PV module's I-V curve which describes how current and voltage vary together
for each solar cell in the module [@miozzo_2014, p. 691].
Here, the I-V curve is given by 
$$
i_{out} = i_{l} - i_{o}[e^{\frac{qv}{n \kappa T}} - 1]
$$ 
with constants $q = 1.6*10^{-19}$ and $\kappa = 1.38 * 10^{-23}$. The light-generated current $i_{l}(t,N) = .0005 I_{eff}(t,N)$ which adjusts $I_{eff}$ for the assumed short circuit current $i_{sc} = 5$ and a radiation rate factor [@miozzo_2014, p. 691].
With a leakage factor $i_{o}$ and the ambient temperature $T$ in degrees Kelvin, $i_{out}$ can be calculated for various voltage values. The combined power of the module is then calculated by 
$$
P = n_{p} n_{s} max\{i_{out} v\}
$$ 
where $n_{p} = 6$ is the assumed number of parallel-wired solar cells in the module and $n_{s} = 6$ is the assumed number of series-wired solar cells in the module [@miozzo_2014, p. 691].
A final conversion efficiency factor $\eta = .211$ is applied and $P'_{max} = \eta P_{max}$ is returned. 

# Bootstrapping


```{r functions, include=FALSE}

#' Given a dataframe, return a matrix of bootstrap blocks
#'
#' @param df A dataframe of irradiance values
#' @return A matrix whose rows are bootstrap blocks
make_blocks_from_df <- function(df) {
  df <- df %>%
    mutate(date = lubridate::make_date(Year, Month, Day))
  # The number of blocks is the number of days
  number_of_blocks <- length(unique(df$date))
  # The length of a block is the number of
  # observations in each individual day.
  # In this case, we can simply look at the first one,
  # because all of the days have the same number of observations
  length_of_block <- nrow(df[df$date == unique(df$date)[1], ])
  blocks <- matrix(NA, nrow = number_of_blocks, ncol = length_of_block)
  start <- 1
  stop <- length_of_block
  for (i in 1:number_of_blocks) {
    # blocks[i, ] <- df$current_out[(i - 1) * length_of_block + 1 : (i * length_of_block)]
    blocks[i, ] <- df$current_out[start:stop]
    start <- start + length_of_block
    stop <- stop + length_of_block
  }
  return(blocks)
}
# We have to use the modified DataFrame here,
# or else the assumptions about block size don't hold
test <- make_blocks_from_df(df_high_irradiance)

block_bootstrap_estimates_from_df <- function(df, B = 10000) {
  block_bootstrap_estimates <- rep(NA, B)
  blocks <- make_blocks_from_df(df)
  number_of_blocks <- nrow(blocks)
  for (i in 1:B) {
    # sample blocks
    idx <- sample(1:number_of_blocks, number_of_blocks, replace = TRUE)
    # Concatenate blocks at the given indices
    # This gives a "pseudo-dataset" containing resampled blocks
    block_bootstrap_estimates[i] <- mean(as.vector(t(blocks[idx, ])))
  }
  return(block_bootstrap_estimates)
}

meanv <- function(data, idx) {
  return(mean(data[idx]))
}

sdv <- function(data, idx) {
  return(sd(data[idx]))
}

medianv <- function(data, idx) {
  return(median(data[idx]))
}

iid_bootstrap_estimates_from_df <- function(df, B = 10000) {
  boot_current <- boot(df$current_out, meanv, B)
  return(boot_current$t)
}

boot_block <- block_bootstrap_estimates_from_df(df_high_irradiance)
boot_block_df <- data.frame(boot = boot_block, type = rep("Block", length(boot_block)))
boot_iid <- iid_bootstrap_estimates_from_df(df_high_irradiance)
boot_iid_df <- data.frame(boot = boot_iid, type = rep("iid", length(boot_iid)))

vis_df <- rbind(boot_block_df, boot_iid_df)

# percentile bootstrap CI used
alpha <- .05
block_ci <- quantile(boot_block_df$boot, c(alpha / 2, 1 - alpha / 2))
iid_ci <- quantile(boot_iid_df$boot, c(alpha / 2, 1 - alpha / 2))

mean_boot_plot <- ggplot(vis_df) +
  geom_histogram(aes(x = boot, y = ..density.., fill = type),
    position = "identity", alpha = .5, color = "black",
    binwidth = .0001
  ) +
  # geom_segment(aes(x = block_ci[1], xend = block_ci[2], y = 1250, yend = 1250), color = 'tomato', alpha = .01) +
  geom_vline(aes(xintercept = block_ci[1]), linetype = "dashed", color = "tomato", alpha = .5) +
  geom_vline(aes(xintercept = block_ci[2]), linetype = "dashed", color = "tomato", alpha = .5) +
  # geom_segment(aes(x = iid_ci[1], xend = iid_ci[2], y = 1300, yend = 1300), color = 'turquoise3', alpha = .01) +
  geom_vline(aes(xintercept = iid_ci[1]), linetype = "dashed", color = "turquoise3", alpha = .5) +
  geom_vline(aes(xintercept = iid_ci[2]), linetype = "dashed", color = "turquoise3", alpha = .5) +
  labs(
    fill = "Bootstrap Type", title = "Bootstrapped Current Output", subtitle = "Percentile confidence intervals given",
    x = "Bootstrap Sample Means", y = "Density"
  ) +
  theme_bw()
ggsave("./images/mean_boot_plot.png", make_plot_for_pres(mean_boot_plot), width = 16, height = 12)
```

```{r, include=FALSE}
# rough MC coverage estimate assuming dependent bootstrap distribution as a null
B <- 10000
n <- nrow(boot_block_df)

lower <- as.numeric(iid_ci[1])
upper <- as.numeric(iid_ci[2])

mu <- mean(boot_block_df$boot)
sigma <- sd(boot_block_df$boot)

sample <- rnorm(B, mu, sigma)

sum(sample >= lower & sample <= upper) / n
```

```{r sampling, include=FALSE}
time_series_irradiance <- function(df, variable, var_name, hour_range) {
  newdf <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    # each day in this dataset is subset from 11:16, meaning there is 6 hours per day
    head(hour_range * 6)

  blocks <- c(newdf$date[seq(1, length(newdf$date), hour_range)])

  ret_plot <- ggplot(newdf) +
    geom_line(aes_string(x = "date", y = variable)) +
    geom_vline(xintercept = blocks, colour = "red") +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

sixhr_plot_current <- time_series_irradiance(df_high_irradiance, "current_out", "Current Output", 6)
ggsave("./images/sixhr_plot_current.png", make_plot_for_pres(sixhr_plot_current))

HOUR_WINDOW <- 8:19
df_more_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_current_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$current_out)) +
  theme_bw()
print(filtered_current_hist)

twelvehr_plot_current <- time_series_irradiance(df_more_irradiance, "current_out", "Current Output", 12)
ggsave("./images/twelvehr_plot_current.png", make_plot_for_pres(twelvehr_plot_current))

day_plot_current <- time_series_irradiance(df, "current_out", "Current Output", 24)
ggsave("./images/day_plot_current.png", make_plot_for_pres(day_plot_current))


# B1 <- df[df$Hour == c(7:10),]$current_output # Hours before peak
# B2 <- df[df$Hour == c(11:14),]$current_output # Peak hours
# B3 <- df[df$Hour == c(15:18),]$current_output # Hours after peak

# nbb(hours, 4) # in order to make b blocks I would need to solve for b = [n/l] (floor) where n is the length of our data and l is 4, so make nbb call l instead of ib

# nbb(hours, 12)

# Could also block instead by hours but by total current output. Peak hours
# would be a frame around the highest output and then hours before and after
# would coincide with that. This would cause the hours to potentially be
# different based on the season/month as months that get dark earlier could see
# peak hours earlier in the day.

# dpeak <- c(B1,B2,B3)
```

# Future Work

For future work, it would be good to examine the wider implications
of the inferential results explored in this paper.
The model paper for this project simulated results for small solar panels
in a specific configuration,
making it hard to generalize the results to any meaningful solar array.
However, if the results could be generalized,
it would be good to see how current output based on solar irradiance
fits into a larger model of uncertainty surrounding renewable energy generation.
One example of such an approach would be @constante_2018,
in which PV output simulated from solar irradiance
is used in conjunction with other sources of of uncertainty.
The estimates of PV output in this paper are only part
of the story with respect to uncertainty in PV power generation.
Other relevant types of uncertainty are uncertainty of energy demand,
uncertainty in personal PV module placement on the grid,
and uncertainty in the power generation of other renewable energy
sources, to name a few (@constante_2018).

\newpage

# References

<div id="refs"></div>

\newpage

# Appendix

```{r show-code, ref.label = all_labels(), echo = TRUE, eval = FALSE}

```



- We chose our initial paper because of its use of Monte Carlo. After working with it for a little it was brought to our attention that Monte Carlo was used in conjunction with a backward/forward sweep method in order to calculate the pdf. After some confusion it was decided to switch to another paper dealing with the same data/motivation but without said methods (including Monte Carlo).
- Luckily, the week after we switched papers we begun learning about bootstrapping, a way to sample from our data while taking into consideration our time change. 

INSERT GRAPHS FROM IID BOOTSTRAPPING AND BLOCK HERE
ALSO INSERT FIG 1 FROM PAPER

- The paper focused most of their sampling on night-day clustering, showing the difference between night and day through current. Night yielded thousands of 0 current values, leading to skewed data when sampling. Instead we took too approaches to bootstrap the current vs. hour data.
- One using non-overlapping blocks sampling from the 8 hours surrounding the peak irradiance. The other being IID, yielding dependence in our data. 
