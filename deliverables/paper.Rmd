---
title: "Time Series Bootstrapping For Solar Current"
author: "Evan Kessler, Adam Kiehl, and Boston Lee"
date: "2021/12/16"
output: bookdown::pdf_document2
bibliography: references.bib
---

```{r reprod, include=FALSE}
# Reproducibility
set.seed(400)
```

```{r libs, include=FALSE, message=FALSE}
# Import packages
library(knitr)
library(bookdown)
library(tidyverse)
library(boot)
```

```{r knitr-opts}
knitr::opts_chunk$set(fig.pos = "t", fig.align = 'center', out.width = "75%", out.extra = "")
```

```{r data, include=FALSE, message=FALSE, warning=FALSE}
# Read in preprocessed data
df <- read_csv("../data/final/irradiance_full_final.csv")
```

```{r plot-pres-func, include=FALSE}
# Function to format plots for use in presentation
make_plot_for_pres <- function(plot) {
  ret_plot <- plot +
    theme(text = element_text(size = 21))
  return(ret_plot)
}
```

# Background


This project began with the search for a research paper
utilizing the process of Monte Carlo sampling or other 
statistcal computing methods. We landed on a few papers 
that did exatcly this, one titled, "SolarStat: Modeling 
Photovoltaic Sources through Stochastic Markov Processes". 
Instead of comparing our works of Monte Carlo simulations 
we were able to utilize a more recent topic discussed in class.
This of course was bootsrapping, a topic we didn't get too in
depth about; however, everything needed to know will be explained 
later on in the paper. Regarding our choice of articles, it was a
question of interest and importance. During the last decade the world
has seen a massive uptick in renewable energy pushes. With this 
new wave of renewables and the rather large misunderstanding of their
total power we decided it would be interesting to look into solar and 
what it was all about. The big question being asked regarding
solar power is whether or not it is worth heading the initial cost
of set up and general mantienance. Many websites inform users of 
just this, according to the Solar.com Learning Center, the average
solar panel net cost is \$2,700 per 1.5 kilowatt-hour system (@solar.com). 
The biggest upside to solar panels is being able to slice down your 
energy bill, and eventually have it pay for itself. In order to 
calculate a solar panels net output experts recommend looking at three things. 
1. Determine your locations peak sun hours (average US around 4 hours/day)
2. Determine your energy compensation (average \$0.03/kilowatt-hour (kWh))
3. Determine your solar panels net energy output
Once you have calculated these three numbers it is as easy as 
multiplying them together to receive your daily solar panel 
compensation (@energysage). As an example Energy Sage looked at 
California receiving 5 peak hours of sunlight a day with a single 
solar panel producing 290 watts/hour. Daily, this panel will produce 
around 1.5 kWh per day yielding the owner a rough compensation 
of \$16.42 a year.

This paper looks at data from a 12 year period to determine the power 
output of a small grid of solar panels
located in Los Angeles, California,
based on solar radiation data.
The information gleaned from simulating power output
can determine if,
on an overall basis, a location produces a sufficient amount 
of power from a solar panel.
This gives customers information to determine
whether or not they should make an investment in solar energy.

# Data

The data used was from the National Solar Radiation Database (NSRDB),
provided by the National Renewable Energy Laboratory
(NREL) (@nsrdb).
The data was acquired via the NSRDB API (@nsrdb_api).

The model paper for this project, @miozzo_2014
used data cited from the NSRDB.
However,
there were some discrepancies between our data
and the data used in @miozzo_2014.
Firstly, the year range in the paper was 1991--2010,
while the year range available when we acquired
the data from the NSRDB API was 1998--2010.
Secondly, the primary variable used in
was extraterrestrial radiation,
"the amount of global horizontal radiation that a location on Earth would
receive if there was no atmosphere" (@nrel_glossary).
Our primary measure was global horizontal radiation (GHI),
which is the total solar radiation to reach
a horizontal plane on the Earth's surface (@nrel_glossary).
Because ETR and GHI are closely related,
we felt that the data was acceptable for a
replication of the process in @miozzo_2014,
with the caveat that the calculations may only be approximate.

# Preprocessing

To translate raw irradiance data into meaningful power data, several steps
had to be taken to simulate the electrical workings of a real PV module. First,
adjustments had to be made to account for the fact that an imperfect amount of
irradiance actually reaches a PV module for capture. Then, effective irradiance
must be translated into output current and maximized with an attached power
processor. The process and accompanying assumptions are given below.

## Effective Irradiance

The effective irradiance that reaches a PV module is different from the total
irradiance emitted by the sun due to a variety of small considerations that
must be made. Among these are the tilt and rotation of the Earth, the latitude
and longitude of the PV module, and the inclination of the panel towards the
horizon. Most simply, $I_{eff} \propto I_{sun} cos \theta(t, N)$ where $\theta
\in [-\frac{\pi}{2},\frac{\pi}{2}]$ is the angle between the sunlight and the
surface of the solar cell [@miozzo_2014, p. 689].
$$
\begin{aligned}
cos \theta(t, N) = & sin \gamma(N) sin La cos \beta - \\
& sin \gamma(N) cos La sin \beta cos \alpha + \\
& cos \gamma(N) cos La cos \beta cos \omega(t,N) + \\
& cos \gamma(N) sin La sin \beta cos \alpha cos \omega(t,N) + \\
& cos \gamma(N) sin \beta sin \alpha sin \omega(t,N) \\
\end{aligned}
$$
Here, $\gamma (N) = sin^{-1}[sin(.409)sin(D(N))]$ is known as the declination angle and is calculated from the angle of the Earth's axis and a metric $D(N) = 360(N - 81)/360$ where $N \in [1, 365]$ is the day of the year [@miozzo_2014, p. 689]. $La \in [0, \frac{\pi}{2}]$ is the latitude of the PV module in radians [@miozzo_2014, p. 689]. $\alpha = .524$ corresponds to whether the panel faces East or West and $\beta = .785$ describes the angle between the panel and the horizon [@miozzo_2014, p. 689].
The constants $\alpha$ and $\beta$
were supplied as assumptions based on the location of the NSRDB
data [@miozzo_2014, p. 691].
Finally, the hour angle $\omega(t, N)$ accounts for the angle of sunlight given the rotation of the Earth [@miozzo_2014, p. 689].
$$
\begin{aligned}
w(t,N) &= 15 (AST(t,N) - 12) \\
AST(t,N) &= t + \Delta t + ET(N) \\
&= t + \frac{Lo - 15 UTC_{off}}{15} + ET(N) \\
ET(N) &= [9.87sin(2D(N)) - 7.53cos(D(N)) - 1.5sin(D(N))] / 60
\end{aligned}
$$
Here, $AST(t,N) \in [0,24]$ is the apparent solar time relative to the sun and is calculated as an adjustment to the current time $t$ based on longitude $Lo$, an offset from the coordinated universal time $UTC_{off}$, and the equation of time $ET(N)$ [@miozzo_2014, p. 689].
The above calculations produce results in degrees but values were switched to radians before trigonometric functions were applied.
Ultimately, $I_{eff} \propto I_{sun} cos \theta(t, N)$ resulted from our astronomical adjustments and was used for PV module
calculations [@miozzo_2014, p. 689].

## PV Module

Within the PV module, effective irradiance is translated into output current
but the entire process is regulated by an attached power processor that ensure
that the maximum power is extracted. It does this by testing a range of open
circuit voltages $v_{oc}$ between zero and an assumed maximum $v_{oc} = 1.8$ on
the PV module's I-V curve which describes how current and voltage vary together
for each solar cell in the module [@miozzo_2014, p. 691].
Here, the I-V curve is given by
$$
i_{out} = i_{l} - i_{o}[e^{\frac{qv}{n \kappa T}} - 1]
$$
with constants $q = 1.6*10^{-19}$ and $\kappa = 1.38 * 10^{-23}$. The light-generated current $i_{l}(t,N) = .0005 I_{eff}(t,N)$ which adjusts $I_{eff}$ for the assumed short circuit current $i_{sc} = 5$ and a radiation rate factor [@miozzo_2014, p. 691].
With a leakage factor $i_{o}$ and the ambient temperature $T$ in degrees Kelvin, $i_{out}$ can be calculated for various voltage values. The combined power of the module is then calculated by
$$
P = n_{p} n_{s} max\{i_{out} v\}
$$
where $n_{p} = 6$ is the assumed number of parallel-wired solar cells in the module and $n_{s} = 6$ is the assumed number of series-wired solar cells in the module [@miozzo_2014, p. 691].
A final conversion efficiency factor $\eta = .211$ is applied and $P'_{max} = \eta P_{max}$ is returned.

# Methods

## Data filtering

```{r filter, include=FALSE}
HOUR_WINDOW <- 11:16
df_high_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_power_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$power_out, y = ..density..), binwidth = .0025) +
  theme_bw() +
  labs(
    title = "Distribution of Power Outputs", subtitle = "Restricted to high irradiance hours of the day",
    x = "Power Output", y = "Density"
  )
print(filtered_power_hist)
```

## Bootstrapping


The main goal of this paper is to provide point and interval
estimates for average (simulated) power output
based on solar irradiance.
Given that the sample size is large,
a simple average may have been sufficient.
However, we were interested in characterizing
the difference in performance between
standard bootstrapping methods and dependent bootstrapping methods.
The power output provides a good test case for this.
Both the preprocessed GHI
and postprocessed power outputs are not independent data;
values of either irradiance or power output
depend on surrounding values in time.
As such, standard methods for bootstrapping should be
less effective at estimating the true mean irradiance output.

The standard (*iid*) bootstrap procedure begins with
the assumption that our original sample consists of
independent and identically distributed draws from a distribution.
The univariate bootstrap then provides a distribution of bootstrap
estimates for a statistic,
$\hat{\theta}^{(1)}, \ldots, \{\hat{\theta}^{(B)}$,
where $B$ is the number of bootstrap replicates
and $\theta$ is a statistic of interest.
For our purposes, $\theta$ is simply the average power output
for our specific solar module configuration.
The *iid* bootstrap constructs the distribution of bootstrap estimates
as follows:

For $i = 1, \ldots, B$:

1. Sample $n$ values $x_j$ from the data with replacement
1. Calculate
   $\hat{\theta}^{(i)} = \frac{1}{n} \sum_{j = 1}^{n} x_j$
   for the bootstrap sample.


In contrast, a dependent bootstrap does not assume
the original sample was independent and identically distributed.
To capture the dependence in the data,
we chose to use a nonparametric non-overlapping block bootstrap.
This is because during the data filtering step,
we excluded nighttime values from the dataset.
This meant we essentially had predefined,
mostly independent blocks from which to sample:
the daytime power values for each day.
Given that our daytime power values for each day
could be used as non-overlapping blocks,
our dataset could be seen as a collection
of $n_B$ blocks.


For i = $1, \ldots, B$:

1. Sample $n_B$ blocks (days)
$\mathcal{B}_{1}, ..., \mathcal{B}_{n_B}$
from the data with replacement.
1. Calculate
   $\hat{\theta}^{(i)} = \frac{1}{n} \sum_{j = 1}^{n} x_j$
   on a new dataset
  $\mathcal{B}_{1} \cup \cdots \cup \mathcal{B}_{n_B}$.


The new dataset in Step 2
corresponds to sampling and rearranging days to make
a new dataset the same size as the original.
This procedure preserves the dependence within days,
while still allowing resampling.

A percentile bootstrap confidence interval was calculated for both the
dependent and *iid* estimates. This method was chosen for its simplicity and
for the fact that the bootstrapped sampling distributions agreed with the
assumption of normality under central limit theorem. Performing an *iid*
bootstrap on dependent data should yield an artificially narrow confidence
interval and this belief was supported by the relative widths of the resulting
intervals. 

# Results

## Descriptive Statistics

```{r timeseries, include=FALSE, warning=FALSE}

#' Plot a timeseries of a single variable
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @param n_days The number of days (starting from the
#'    beginning of the data) to plot
#' @return A ggplot object of a timeseries of `variable` for `n_days` days
time_series_of_var <- function(df, variable, var_name, n_days) {
  ret_plot <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    head(24 * n_days) %>%
    ggplot() +
    geom_line(aes_string(x = "date", y = variable)) +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

time_series_ghi <- time_series_of_var(df, "GHI", "GHI", 6)
time_series_power <- time_series_of_var(df, "power_out", "Output power", 6)
ggsave("./images/time_series_ghi.png", make_plot_for_pres(time_series_ghi))
ggsave("./images/time_series_power.png", make_plot_for_pres(time_series_power))
```

```{r hour-plot, include=FALSE}

#' Plot the values of `variable` at each hour of the day
#'
#' @param df A dataframe containing `variable`
#' @param variable A string referring to a column of `df`
#' @param var_name The human-readable name of `variable`, for labelling
#' @return A ggplot object of a boxplot of `variable` segmented by hour
hour_plot_of_var <- function(df, variable, var_name) {
  df$Hour <- as.factor(df$Hour)
  ret_plot <- df %>%
    ggplot() +
    geom_boxplot(aes_string(x = "Hour", y = variable)) +
    xlab("Hour (0-23)") +
    ylab(paste("Distribution of", var_name)) +
    scale_x_discrete(breaks = seq(0, 23, 2)) +
    theme_bw()
  return(ret_plot)
}

hour_plot_ghi <- hour_plot_of_var(df, "GHI", "GHI")
hour_plot_power <- hour_plot_of_var(df, "power_out", "Output Power")
ggsave("./images/hour_plot_ghi.png", make_plot_for_pres(hour_plot_ghi))
ggsave("./images/hour_plot_power.png", make_plot_for_pres(hour_plot_power))
```

```{r ghi-ts, fig.cap="Time series of GHI values for the first six days in the dataset", echo=FALSE}
print(time_series_ghi)
```

```{r power-ts, fig.cap="Time series of simulated power values for the first six days in the dataset.", echo=FALSE}
print(time_series_power)
```

```{r ghi-hour-boxplot, fig.cap="Distribution of GHI at each hour for the entire unfiltered dataset.", echo=FALSE}
print(hour_plot_ghi)
```

```{r power-hour-boxplot, fig.cap="Distribution of GHI at each hour for the entire unfiltered dataset.", echo=FALSE}
print(hour_plot_power)
```


## Bootstrapping

```{r functions, include=FALSE}

#' Given a dataframe, return a matrix of bootstrap blocks
#'
#' @param df A dataframe of irradiance values
#' @return A matrix whose rows are bootstrap blocks
make_blocks_from_df <- function(df) {
  df <- df %>%
    mutate(date = lubridate::make_date(Year, Month, Day))
  # The number of blocks is the number of days
  number_of_blocks <- length(unique(df$date))
  # The length of a block is the number of
  # observations in each individual day.
  # In this case, we can simply look at the first one,
  # because all of the days have the same number of observations
  length_of_block <- nrow(df[df$date == unique(df$date)[1], ])
  blocks <- matrix(NA, nrow = number_of_blocks, ncol = length_of_block)
  start <- 1
  stop <- length_of_block
  for (i in 1:number_of_blocks) {
    # blocks[i, ] <- df$current_out[(i - 1) * length_of_block + 1 : (i * length_of_block)]
    blocks[i, ] <- df$power_out[start:stop]
    start <- start + length_of_block
    stop <- stop + length_of_block
  }
  return(blocks)
}
# We have to use the modified DataFrame here,
# or else the assumptions about block size don't hold
test <- make_blocks_from_df(df_high_irradiance)

block_bootstrap_estimates_from_df <- function(df, B = 10000) {
  block_bootstrap_estimates <- rep(NA, B)
  blocks <- make_blocks_from_df(df)
  number_of_blocks <- nrow(blocks)
  for (i in 1:B) {
    # sample blocks
    idx <- sample(1:number_of_blocks, number_of_blocks, replace = TRUE)
    # Concatenate blocks at the given indices
    # This gives a "pseudo-dataset" containing resampled blocks
    block_bootstrap_estimates[i] <- mean(as.vector(t(blocks[idx, ])))
  }
  return(block_bootstrap_estimates)
}

meanv <- function(data, idx) {
  return(mean(data[idx]))
}

sdv <- function(data, idx) {
  return(sd(data[idx]))
}

medianv <- function(data, idx) {
  return(median(data[idx]))
}

iid_bootstrap_estimates_from_df <- function(df, B = 10000) {
  boot_power <- boot(df$power_out, meanv, B)
  return(boot_power$t)
}

boot_block <- block_bootstrap_estimates_from_df(df_high_irradiance)
boot_block_df <- data.frame(boot = boot_block, type = rep("Block", length(boot_block)))
boot_iid <- iid_bootstrap_estimates_from_df(df_high_irradiance)
boot_iid_df <- data.frame(boot = boot_iid, type = rep("iid", length(boot_iid)))

vis_df <- rbind(boot_block_df, boot_iid_df)

# percentile bootstrap CI used
alpha <- .05
block_ci <- quantile(boot_block_df$boot, c(alpha / 2, 1 - alpha / 2))
iid_ci <- quantile(boot_iid_df$boot, c(alpha / 2, 1 - alpha / 2))

mean_boot_plot <- ggplot(vis_df) +
  geom_histogram(aes(x = boot, y = ..density.., fill = type),
    position = "identity", alpha = .5, color = "black"
  ) +
  # geom_segment(aes(x = block_ci[1], xend = block_ci[2], y = 1250, yend = 1250), color = 'tomato', alpha = .01) +
  geom_vline(aes(xintercept = block_ci[1]), linetype = "dashed", color = "tomato", alpha = .5) +
  geom_vline(aes(xintercept = block_ci[2]), linetype = "dashed", color = "tomato", alpha = .5) +
  # geom_segment(aes(x = iid_ci[1], xend = iid_ci[2], y = 1300, yend = 1300), color = 'turquoise3', alpha = .01) +
  geom_vline(aes(xintercept = iid_ci[1]), linetype = "dashed", color = "turquoise3", alpha = .5) +
  geom_vline(aes(xintercept = iid_ci[2]), linetype = "dashed", color = "turquoise3", alpha = .5) +
  labs(
    fill = "Bootstrap Type", title = "Bootstrapped Power Output", subtitle = "Percentile confidence intervals given",
    x = "Bootstrap Sample Means", y = "Density"
  ) +
  theme_bw()
ggsave("./images/mean_boot_plot.png", make_plot_for_pres(mean_boot_plot), width = 16, height = 12)
```

```{r mean-boot-plot, fig.cap="Distributions of bootstrap mean simulated power for both iid and block bootstrapping methods. Percentile 95 percent bootstrap confidence intervals for mean simulated power overlayed.", echo=FALSE}
print(mean_boot_plot)
```

```{r bootstrap-ci, echo=FALSE}
bootstrap_ci_table <- rbind(
c("iid", paste("(", round(iid_ci[1],3),",", round(iid_ci[2],3), ")")),
c("Block", paste("(", round(block_ci[1],3),",", round(block_ci[2], 3), ")"))
)
colnames(bootstrap_ci_table) <- c("Bootstrap Method", "95% CI")
rownames(bootstrap_ci_table) <- c()

bootstrap_ci_table %>% kable(booktabs = TRUE,
caption="95% confidence intervals for the mean simulated power, as generated by each of the two bootstrapping methods.")


```



```{r sampling, include=FALSE}
time_series_irradiance <- function(df, variable, var_name, hour_range) {
  newdf <- df %>%
    mutate(date = lubridate::make_datetime(Year, Month, Day, Hour, Minute)) %>%
    # each day in this dataset is subset from 11:16, meaning there is 6 hours per day
    head(hour_range * 6)

  blocks <- c(newdf$date[seq(1, length(newdf$date), hour_range)])

  ret_plot <- ggplot(newdf) +
    geom_line(aes_string(x = "date", y = variable)) +
    geom_vline(xintercept = blocks, colour = "red") +
    xlab("Date") +
    ylab(var_name) +
    theme_bw()
  return(ret_plot)
}

sixhr_plot_power <- time_series_irradiance(df_high_irradiance, "power_out", "Power Output", 6)
ggsave("./images/sixhr_plot_power.png", make_plot_for_pres(sixhr_plot_power))

HOUR_WINDOW <- 8:19
df_more_irradiance <- df[df$Hour %in% HOUR_WINDOW, ]
filtered_power_hist <- ggplot() +
  geom_histogram(aes(x = df_high_irradiance$power_out)) +
  theme_bw()
print(filtered_power_hist)

twelvehr_plot_power <- time_series_irradiance(df_more_irradiance, "power_out", "Power Output", 12)
ggsave("./images/twelvehr_plot_power.png", make_plot_for_pres(twelvehr_plot_power))

day_plot_power <- time_series_irradiance(df, "power_out", "Power Output", 24)
ggsave("./images/day_plot_power.png", make_plot_for_pres(day_plot_power))


# B1 <- df[df$Hour == c(7:10),]$current_output # Hours before peak
# B2 <- df[df$Hour == c(11:14),]$current_output # Peak hours
# B3 <- df[df$Hour == c(15:18),]$current_output # Hours after peak

# nbb(hours, 4) # in order to make b blocks I would need to solve for b = [n/l] (floor) where n is the length of our data and l is 4, so make nbb call l instead of ib

# nbb(hours, 12)

# Could also block instead by hours but by total current output. Peak hours
# would be a frame around the highest output and then hours before and after
# would coincide with that. This would cause the hours to potentially be
# different based on the season/month as months that get dark earlier could see
# peak hours earlier in the day.

# dpeak <- c(B1,B2,B3)
```

# Discussion

The power estimate generated in this study has practical applications in real-world electrical engineering problems. An allocation must be made that balances the expected contribution of renewable energy sources with the expected residual demand on the electrical grid. An intelligent estimate of the contribution from PV modules must account for geographical deviations in solar irradiance. While the estimate here was made for Los Angeles, this framework can be applied to any location for which irradiance data is tracked. This framework could also be applied to intervals of time where power estimates could be made for each hour of the day or for each day of the year; greater stratified specificity would improve the real-world usefulness of this method. Further work...

I THINK DISCUSSION AND FUTURE WORK SHOULD BE COMBINED. THEY FLOW INTO EACH OTHER QUITE NICELY. FEEL FREE TO MERGE THEM IF YOU WANT.

# Future Work

For future work, it would be good to examine the wider implications
of the inferential results explored in this paper.
The model paper for this project simulated results for small solar panels
in a specific configuration,
making it hard to generalize the results to any meaningful solar array.
However, if the results could be generalized,
it would be good to see how power output based on solar irradiance
fits into a larger model of uncertainty surrounding renewable energy generation.
One example of such an approach would be @constante_2018,
in which PV output simulated from solar irradiance
is used in conjunction with other sources of of uncertainty.
The estimates of PV output in this paper are only part
of the story with respect to uncertainty in PV power generation.
Other relevant types of uncertainty are uncertainty of energy demand,
uncertainty in personal PV module placement on the grid,
and uncertainty in the power generation of other renewable energy
sources, to name a few (@constante_2018).

\newpage

# References

<div id="refs"></div>

\newpage

# Appendix

```{r show-code, ref.label = all_labels(), echo = TRUE, eval = FALSE}

```



- We chose our initial paper because of its use of Monte Carlo. After working with it for a little it was brought to our attention that Monte Carlo was used in conjunction with a backward/forward sweep method in order to calculate the pdf. After some confusion it was decided to switch to another paper dealing with the same data/motivation but without said methods (including Monte Carlo).
- Luckily, the week after we switched papers we begun learning about bootstrapping, a way to sample from our data while taking into consideration our time change.

INSERT GRAPHS FROM IID BOOTSTRAPPING AND BLOCK HERE
ALSO INSERT FIG 1 FROM PAPER

- The paper focused most of their sampling on night-day clustering, showing the difference between night and day through current. Night yielded thousands of 0 current values, leading to skewed data when sampling. Instead we took too approaches to bootstrap the current vs. hour data.
- One using non-overlapping blocks sampling from the 8 hours surrounding the peak irradiance. The other being IID, yielding dependence in our data.
